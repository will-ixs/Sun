#version 450
#extension GL_EXT_buffer_reference : require

#define M_PI 3.1415926535897932384626433832795
#define NUM_PARTICLES 64000
#define TABLE_SIZE 129631 
const uint PRIME1 = 19349663;
const uint PRIME2 = 73856093;
const uint PRIME3 = 83492791;
layout(local_size_x = 64, local_size_y = 1, local_size_z = 1) in;

const uint OFFSET_CURR_POS      	= 0;
const uint OFFSET_PREV_POS      	= 3 * NUM_PARTICLES;
const uint OFFSET_VELOCITY      	= 6 * NUM_PARTICLES;
const uint OFFSET_DELTA         	= 9 * NUM_PARTICLES;
const uint OFFSET_COLLISIONS    	= 12 * NUM_PARTICLES;
const uint OFFSET_VORTICITY     	= 15 * NUM_PARTICLES;
const uint OFFSET_VORTICITY_GRAD	= 18 * NUM_PARTICLES;
const uint OFFSET_VISCOSITY     	= 21 * NUM_PARTICLES;
const uint OFFSET_LAMBDAS       	= 24 * NUM_PARTICLES;

layout(buffer_reference, std430) buffer ParticleBuffer{ 
	float data[];
};
layout(buffer_reference, std430) buffer UintBuffer{ 
	uint data[];
};

layout( push_constant ) uniform constants
{	
	ParticleBuffer particleBuffer;    
    UintBuffer gridCounter;
    UintBuffer gridCells;
    float timestep;
    float smoothingRadius;
    float restDensity;
    float particleMass;
    vec3 minBoundingPos;
    vec3 maxBoundingPos;
} PushConstants;

vec3 loadVec3(uint baseOffset, uint index){
    return vec3(
        PushConstants.particleBuffer.data[baseOffset + (3 * index) + 0],
        PushConstants.particleBuffer.data[baseOffset + (3 * index) + 1],
        PushConstants.particleBuffer.data[baseOffset + (3 * index) + 2]
    );
}
void storeVec3(uint baseOffset, uint index, vec3 value) {
    PushConstants.particleBuffer.data[baseOffset + (3 * index) + 0] = value.x;
    PushConstants.particleBuffer.data[baseOffset + (3 * index) + 0] = value.y;
    PushConstants.particleBuffer.data[baseOffset + (3 * index) + 0] = value.z;
}
float loadFloat(uint baseOffset, uint index){
    return PushConstants.particleBuffer.data[baseOffset + (3 * index)];
}
void storeFloat(uint baseOffset, uint index, float value) {
    PushConstants.particleBuffer.data[baseOffset + (3 * index)] = value;
}
uint hashGridCoord(int x, int y, int z) {    
    uint xOffset = (x < 0) ? 1u : 0u;
    uint yOffset = (y < 0) ? 1u : 0u;
    uint zOffset = (z < 0) ? 1u : 0u;

    uint ux = uint(x) * 2u + xOffset;
    uint uy = uint(y) * 2u + yOffset;
    uint uz = uint(z) * 2u + zOffset;

    uint hash = (ux * PRIME1) ^ (uy * PRIME2) ^ (uz * PRIME3);
    return hash % TABLE_SIZE;
}
float densityKernel(float r){
    float factor = 315.0 / (64.0 * M_PI * pow(smoothingRadius, 9.0));
    return factor * pow((smoothingRadius * smoothingRadius) - (r * r), 3.0);
}
float gradientKernel(float r){
    float factor = (45.0 / M_PI) * pow(smoothingRadius, 6.0);
    return factor * pow((smoothingRadius - r), 2.0);
}

void main() {
    uint index = gl_GlobalInvocationID.x;
    if (index >= NUM_PARTICLES) return;

    vec3 currPos = loadVec3(OFFSET_CURR_POS, index);
    ivec3 cellPos = floor(currPos/smoothingRadius);
    //Calculate lambdas
            
    // Compute density
    float density = 0.0;
    for(int dx = -1; dx<=1; dx++;){
    for(int dy = -1; dy<=1; dy++;){
    for(int dz = -1; dz<=1; dz++;){

        ivec3 neighborCell = cellPos + ivec3(dx, dy, dz);
        uint cellHash = hashGridCoord(neighborCell.x, neighborCell.y, neighborCell.z);
        uint cellCount = gridCounter.data[cellHash];
        for(int i = 0; i < cellCount; i++){
            uint particleIndex = gridCells.data[(10 * cellHash) + i];            
            if(particleIndex == index){
                continue;
            }
            vec3 neighborPos = loadVec3(OFFSET_CURR_POS, particleIndex);
            float r = length(neighborPos - currPos);
            if(r < smoothingRadius){
                density += densityKernel(r);
            }
        }

    }
    }
    }

    float Ci = (density / PushConstants.restDensity ) - 1.0f;
    float gradSum = 0.0;
    vec3 gradAccum = vec3(0.0);

    for(int dx = -1; dx<=1; dx++;){
    for(int dy = -1; dy<=1; dy++;){
    for(int dz = -1; dz<=1; dz++;){
        ivec3 neighborCell = cellPos + ivec3(dx, dy, dz);
        uint cellHash = hashGridCoord(neighborCell.x, neighborCell.y, neighborCell.z);
        uint cellCount = gridCounter.data[cellHash];
        for(int i = 0; i < cellCount; i++){
            uint particleIndex = gridCells.data[(10 * cellHash) + i];
            if(particleIndex == index){
                continue;
            }
            vec3 neighborPos = loadVec3(OFFSET_CURR_POS, particleIndex);
            vec3 grad = (gradientKernel(length(currPos - neighbor)) * normalize(currPos - neighbor)) / restDensity;
            gradSum += dot(grad, grad);
            gradAccum += grad;
            }
        }
    }
    }
    }
    gradSum += dot(-grad_i, -grad_i);
    float lambda = -Ci / (gradSum + epsilon);
    storeFloat(OFFSET_LAMBDAS, index, lambda);

    //Calculate Dpi
    vec3 delta = vec3(0.0);
    for(int dx = -1; dx<=1; dx++;){
    for(int dy = -1; dy<=1; dy++;){
    for(int dz = -1; dz<=1; dz++;){
        ivec3 neighborCell = cellPos + ivec3(dx, dy, dz);
        uint cellHash = hashGridCoord(neighborCell.x, neighborCell.y, neighborCell.z);
        uint cellCount = gridCounter.data[cellHash];
        for(int i = 0; i < cellCount; i++){
            uint particleIndex = gridCells.data[(10 * cellHash) + i];
            if(particleIndex == index){
                continue;
            }
            vec3 neighborPos = loadVec3(OFFSET_CURR_POS, particleIndex);
            vec3 grad = gradientKernel(length(currPos - neighbor)) * normalize(currPos - neighbor);
            delta += (loadFloat(OFFSET_LAMBDAS, index) + loadFloat(OFFSET_LAMBDAS, particleIndex)) * grad;
        }
    }
    }
    }
    delta /= PushConstants.restDensity;

    //Apply dpi
    storeVec3(OFFSET_DELTA, index, delta);

    //Set velocity, bounce  / Collision handling
    vec3 newPos = currPos + delta;
    vec3 collision = vec3(1.0);
    float radius = 0.1;

    if(newPos.x - radius < minBoundingPos.x){
        delta.x = minBoundingPos.x + radius - currPos.x;
        collision.x *= -1.0;
    }else if (newPos.x + radius > maxBoundingPos.x){
        delta.x = maxBoundingPos.x - radius - currPos.x;
        collision.x *= -1.0;
    }     
    
    if(newPos.y - radius < minBoundingPos.y){
        delta.y = minBoundingPos.y + radius - currPos.y;
        collision.y *= -1.0;
    }else if (newPos.y + radius > mayBoundingPos.y){
        delta.y = mayBoundingPos.y - radius - currPos.y;
        collision.y *= -1.0;
    }     
    
    if(newPos.z - radius < minBoundingPos.z){
        delta.z = minBoundingPos.z + radius - currPos.z;
        collision.z *= -1.0;
    }else if (newPos.z + radius > mazBoundingPos.z){
        delta.z = mazBoundingPos.z - radius - currPos.z;
        collision.z *= -1.0;
    }

    currPos += delta;
    vec3 vel = loadVec3(OFFSET_VELOCITY, index);
    vec3 prevPos = loadVec(OFFSET_PREV_POS, index);
    vel = (1.0/timestep) * (currPos - prevPos);
    vel.x *= collision.x;
    vel.y *= collision.y;
    vel.z *= collision.z;
    storeVec3(OFFSET_VELOCITY, index, vel);
}
