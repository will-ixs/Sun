#version 450
#extension GL_EXT_buffer_reference : require
#extension GL_EXT_shader_atomic_int64: require

layout(local_size_x = 8, local_size_y = 8, local_size_z = 8) in;

#define M_PI 3.1415926535897932384626433832795
#define NUM_PARTICLES 125000
#define TABLE_SIZE 251087 

const uint PRIME1 = 19349663;
const uint PRIME2 = 73856093;
const uint PRIME3 = 83492791;

const uint OFFSET_CURR_POS      	= 0;
const uint OFFSET_PREV_POS      	= 3 * NUM_PARTICLES;
const uint OFFSET_VELOCITY      	= 6 * NUM_PARTICLES;
const uint OFFSET_DELTA         	= 9 * NUM_PARTICLES;
const uint OFFSET_COLLISIONS    	= 12 * NUM_PARTICLES;
const uint OFFSET_VORTICITY     	= 15 * NUM_PARTICLES;
const uint OFFSET_VORTICITY_GRAD	= 18 * NUM_PARTICLES;
const uint OFFSET_VISCOSITY     	= 21 * NUM_PARTICLES;
const uint OFFSET_LAMBDAS       	= 24 * NUM_PARTICLES;

layout(buffer_reference, std430) buffer ParticleBuffer{ 
	float data[];
};
layout(buffer_reference, std430) buffer UintBuffer{ 
	uint data[];
};

layout(set = 0, binding = 1) uniform sampler3D samplers[];
layout(set = 0, binding = 2, r16f) uniform image3D storageImages3D[];

layout( push_constant ) uniform constants
{	
	ParticleBuffer particleBuffer;    
    UintBuffer gridCounter;
    UintBuffer gridCells;
    UintBuffer neighborCount;
    UintBuffer neighborList;
    float timestep;
    float smoothingRadius;
    float restDensity;
    float particleMass;
    vec3 minBoundingPos;
    vec3 maxBoundingPos;
    
} PushConstants;

vec3 loadVec3(uint baseOffset, uint index){
    return vec3(
        PushConstants.particleBuffer.data[baseOffset + (3 * index) + 0],
        PushConstants.particleBuffer.data[baseOffset + (3 * index) + 1],
        PushConstants.particleBuffer.data[baseOffset + (3 * index) + 2]
    );
}

float densityKernel(float r){
    float factor = 315.0 / (64.0 * M_PI * (pow(PushConstants.smoothingRadius, 9.0)));
    return factor * pow(((PushConstants.smoothingRadius * PushConstants.smoothingRadius) - (r * r)), 3.0);
}

uint hashGridCoord(int x, int y, int z) {    
    uint xOffset = (x < 0) ? 1u : 0u;
    uint yOffset = (y < 0) ? 1u : 0u;
    uint zOffset = (z < 0) ? 1u : 0u;

    uint ux = uint(x) * 2u + xOffset;
    uint uy = uint(y) * 2u + yOffset;
    uint uz = uint(z) * 2u + zOffset;

    uint hash = (ux * PRIME1) ^ (uy * PRIME2) ^ (uz * PRIME3);
    return hash % TABLE_SIZE;
}

void main() {
    ivec3 index = ivec3(gl_GlobalInvocationID);
    if (index.x >= 256 || index.y >= 256 || index.z >= 256) return;
    
    const uint maxNeighbors = 12 * 27;
    vec3 cellSize = (PushConstants.maxBoundingPos - PushConstants.minBoundingPos) / vec3(256.0);
    vec3 cellCenter = PushConstants.minBoundingPos + (vec3(index) + 0.5) * cellSize;

    ivec3 cellPos = ivec3(floor(cellCenter / PushConstants.smoothingRadius));
    float density = 0;
    uint cellCount = 0;
    for(int dx = -1; dx<=1; dx++){
    for(int dy = -1; dy<=1; dy++){
    for(int dz = -1; dz<=1; dz++){
        ivec3 neighborCell = cellPos + ivec3(dx, dy, dz);
        uint neighborHash = hashGridCoord(neighborCell.x, neighborCell.y, neighborCell.z);
        cellCount = PushConstants.gridCounter.data[neighborHash];
        cellCount = cellCount < maxNeighbors ? cellCount : maxNeighbors;
    
        for(uint i = 0u; i < cellCount; i++){
       	    uint neighborIndex = PushConstants.gridCells.data[(12 * neighborHash) + i];            
	        vec3 neighborPos = loadVec3(OFFSET_CURR_POS, neighborIndex);

            float r = length(cellCenter - neighborPos);
            if(r * r < PushConstants.smoothingRadius * PushConstants.smoothingRadius){
                density += densityKernel(r);
            }
        }
    }}}
    float cf = cellCount;
    imageStore(storageImages3D[0], index, vec4(density, 0.0, 0.0, 1.0));
}
