 #version 450
#extension GL_EXT_buffer_reference : require

#define M_PI 3.1415926535897932384626433832795
#define NUM_PARTICLES 125000
#define TABLE_SIZE 251087 
const uint PRIME1 = 19349663;
const uint PRIME2 = 73856093;
const uint PRIME3 = 83492791;
layout(local_size_x = 64, local_size_y = 1, local_size_z = 1) in;

const uint OFFSET_CURR_POS      	= 0;
const uint OFFSET_PREV_POS      	= 3 * NUM_PARTICLES;
const uint OFFSET_VELOCITY      	= 6 * NUM_PARTICLES;
const uint OFFSET_DELTA         	= 9 * NUM_PARTICLES;
const uint OFFSET_COLLISIONS    	= 12 * NUM_PARTICLES;
const uint OFFSET_VORTICITY     	= 15 * NUM_PARTICLES;
const uint OFFSET_VORTICITY_GRAD	= 18 * NUM_PARTICLES;
const uint OFFSET_VISCOSITY     	= 21 * NUM_PARTICLES;
const uint OFFSET_LAMBDAS       	= 24 * NUM_PARTICLES;

layout(buffer_reference, std430) buffer ParticleBuffer{ 
	float data[];
};
layout(buffer_reference, std430) buffer UintBuffer{ 
	uint data[];
};

layout( push_constant ) uniform constants
{	
	ParticleBuffer particleBuffer;    
    UintBuffer gridCounter;
    UintBuffer gridCells;
    UintBuffer neighborCount;
    UintBuffer neighborList;
    float timestep;
    float smoothingRadius;
    float restDensity;
    float particleMass;
    vec3 minBoundingPos;
    vec3 maxBoundingPos;
} PushConstants;


vec3 loadVec3(uint baseOffset, uint index){
    return vec3(
        PushConstants.particleBuffer.data[baseOffset + (3 * index) + 0],
        PushConstants.particleBuffer.data[baseOffset + (3 * index) + 1],
        PushConstants.particleBuffer.data[baseOffset + (3 * index) + 2]
    );
}
void storeVec3(uint baseOffset, uint index, vec3 value) {
    PushConstants.particleBuffer.data[baseOffset + (3 * index) + 0] = value.x;
    PushConstants.particleBuffer.data[baseOffset + (3 * index) + 1] = value.y;
    PushConstants.particleBuffer.data[baseOffset + (3 * index) + 2] = value.z;
}
float loadFloat(uint baseOffset, uint index){
    return PushConstants.particleBuffer.data[baseOffset + index];
}
void storeFloat(uint baseOffset, uint index, float value) {
    PushConstants.particleBuffer.data[baseOffset + index] = value;
}
uint hashGridCoord(int x, int y, int z) {    
    uint xOffset = (x < 0) ? 1u : 0u;
    uint yOffset = (y < 0) ? 1u : 0u;
    uint zOffset = (z < 0) ? 1u : 0u;

    uint ux = uint(x) * 2u + xOffset;
    uint uy = uint(y) * 2u + yOffset;
    uint uz = uint(z) * 2u + zOffset;

    uint hash = (ux * PRIME1) ^ (uy * PRIME2) ^ (uz * PRIME3);
    return hash % TABLE_SIZE;
}

void main() {
    uint index = gl_GlobalInvocationID.x;
    if (index >= NUM_PARTICLES) return;

    vec3 currPos = loadVec3(OFFSET_CURR_POS, index);
    vec3 prevPos = loadVec3(OFFSET_PREV_POS, index);
    vec3 deltaP = loadVec3(OFFSET_DELTA, index);
    
    vec3 newPos = currPos + deltaP;
    vec3 collision = vec3(1.0);
    float dampingFactor = 1.0;
    // check each axis for collision and invert velocity if crossing
    //X
    if (newPos.x < PushConstants.minBoundingPos.x) {
        newPos.x = PushConstants.minBoundingPos.x;
        collision.x *= -dampingFactor;
    } else if (newPos.x > PushConstants.maxBoundingPos.x) {
        newPos.x = PushConstants.maxBoundingPos.x;
        collision.x *= -dampingFactor;
    }
    //Y
    if (newPos.y < PushConstants.minBoundingPos.y) {
        newPos.y = PushConstants.minBoundingPos.y;
        collision.y *= -dampingFactor;
    } else if (newPos.y > PushConstants.maxBoundingPos.y) {
        newPos.y = PushConstants.maxBoundingPos.y;
        collision.y *= -dampingFactor;
    }
    //Z
    if (newPos.z < PushConstants.minBoundingPos.z) {
        newPos.z = PushConstants.minBoundingPos.z;
        collision.z *= -dampingFactor;
    } else if (newPos.z > PushConstants.maxBoundingPos.z) {
        newPos.z = PushConstants.maxBoundingPos.z;
        collision.z *= -dampingFactor;
    }

    vec3 finalVel = (newPos - prevPos) / PushConstants.timestep;
    finalVel.x *= collision.x;
    finalVel.y *= collision.y;
    finalVel.z *= collision.z;
    storeVec3(OFFSET_CURR_POS, index, newPos);
    storeVec3(OFFSET_VELOCITY, index, finalVel);
}